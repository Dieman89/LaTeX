
@misc{apolloIntroductionApolloStudio2021,
  title = {Introduction to {{Apollo Studio}}},
  author = {Apollo},
  year = {2021},
  journal = {Apollo Docs},
  url = {https://www.apollographql.com/docs/studio/},
  urldate = {2022-03-19},
  file = {/Users/dieman/Zotero/storage/ABSTPN4C/studio.html}
}

@article{britoMigratingGraphQLPractical2019,
  title = {Migrating to {{GraphQL}}: {{A Practical Assessment}}},
  shorttitle = {Migrating to {{GraphQL}}},
  author = {Brito, Gleison and Mombach, Thais and Valente, Marco Tulio},
  year = {2019},
  month = jun,
  journal = {arXiv:1906.07535 [cs]},
  eprint = {1906.07535},
  eprinttype = {arxiv},
  primaryclass = {cs},
  doi = {10.1109/SANER.2019.8667986},
  url = {http://arxiv.org/abs/1906.07535},
  urldate = {2022-03-24},
  abstract = {GraphQL is a novel query language proposed by Facebook to implement Web-based APIs. In this paper, we present a practical study on migrating API clients to this new technology. First, we conduct a grey literature review to gain an in-depth understanding on the benefits and key characteristics normally associated to GraphQL by practitioners. After that, we assess such benefits in practice, by migrating seven systems to use GraphQL, instead of standard REST-based APIs. As our key result, we show that GraphQL can reduce the size of the JSON documents returned by REST APIs in 94\% (in number of fields) and in 99\% (in number of bytes), both median results.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Software Engineering},
  note = {Comment: 11 pages. Accepted at 26th International Conference on Software Analysis, Evolution and Reengineering},
  file = {/Users/dieman/Zotero/storage/JERCLLNM/Brito et al. - 2019 - Migrating to GraphQL A Practical Assessment.pdf;/Users/dieman/Zotero/storage/JMEJRVHW/1906.html}
}

@inproceedings{britoRESTVsGraphQL2020,
  title = {{{REST}} vs {{GraphQL}}: {{A Controlled Experiment}}},
  shorttitle = {{{REST}} vs {{GraphQL}}},
  booktitle = {2020 {{IEEE International Conference}} on {{Software Architecture}} ({{ICSA}})},
  author = {Brito, Gleison and Valente, Marco Tulio},
  year = {2020},
  month = mar,
  pages = {81--91},
  doi = {10.1109/ICSA47634.2020.00016},
  abstract = {GraphQL is a novel query language for implementing service-based software architectures. The language is gaining momentum and it is now used by major software companies, such as Facebook and GitHub. However, we still lack empirical evidence on the real gains achieved by GraphQL, particularly in terms of the effort required to implement queries in this language. Therefore, in this paper we describe a controlled experiment with 22 students (10 undergraduate and 12 graduate), who were asked to implement eight queries for accessing a web service, using GraphQL and REST. Our results show that GraphQL requires less effort to implement remote service queries when compared to REST (9 vs 6 minutes, median times). These gains increase when REST queries include more complex endpoints, with several parameters. Interestingly, GraphQL outperforms REST even among more experienced participants (as is the case of graduate students) and among participants with previous experience in REST, but no previous experience in GraphQL.},
  keywords = {Database languages,Facebook,GraphQL,REST,Servers,Standards,Task analysis,Uniform resource locators,Web APIs,Web services},
  file = {/Users/dieman/Zotero/storage/9Q6FIMH5/Brito and Valente - 2020 - REST vs GraphQL A Controlled Experiment.pdf;/Users/dieman/Zotero/storage/NPGE8KS4/9101226.html}
}

@misc{derksDocumentingGraphQLAPIs2021,
  title = {Documenting {{GraphQL APIs}} | {{HackerNoon}}},
  author = {Derks, Roy},
  year = {2021},
  url = {https://hackernoon.com/documenting-graphql-apis},
  urldate = {2022-03-19},
  abstract = {The main reason for writing API documentation is to make your API understandable. For GraphQL there are many options. Both interactive and static documentation.},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/52B3E62V/documenting-graphql-apis.html}
}

@article{eizingerAPIDesignDistributed2017,
  title = {{{API Design}} in {{Distributed Systems}}: {{A Comparison}} between {{GraphQL}} and {{REST}}},
  author = {Eizinger, Thomas},
  year = {2017},
  pages = {73},
  abstract = {When Facebook open-sourced the GraphQL specification in 2015, many developers welcomed this new way of writing APIs for their clients. GraphQL solves a few problems that can occur when using a resource-based approach for the API design, an approach that is often falsely labeled as RESTful. This thesis makes an effort in clearly to distinguish between such resourcebased approaches and actually RESTful systems. It identifies key aspects in the design of APIs and compares the impact of GraphQL and REST on these aspects. As a result of the comparison, several consequences are identified and presented. A consequence that stands out through its importance is the shift in responsibility between client and server which causes, depending on the use-case, highly increased complexity of the client.},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/TPDXPGIW/Eizinger - API Design in Distributed Systems A Comparison be.pdf}
}

@article{fanWhyAPIDocumentation2021,
  title = {Why {{API}} Documentation Is Insufficient for Developers: An Empirical Study},
  shorttitle = {Why {{API}} Documentation Is Insufficient for Developers},
  author = {Fan, Qiang and Yu, Yue and Wang, Tao and Yin, Gang and Wang, Huaimin},
  year = {2021},
  month = jan,
  journal = {Science China Information Sciences},
  volume = {64},
  number = {1},
  pages = {119102},
  issn = {1674-733X, 1869-1919},
  doi = {10.1007/s11432-019-9880-8},
  url = {http://link.springer.com/10.1007/s11432-019-9880-8},
  urldate = {2021-10-09},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/AHAAF7QW/Fan et al. - 2021 - Why API documentation is insufficient for develope.pdf}
}

@misc{freecodecampWhatJAMstackHow2020,
  title = {What Is the {{JAMstack}} and How Do {{I}} Get Started?},
  author = {{freeCodeCamp}},
  year = {2020},
  month = feb,
  journal = {freeCodeCamp.org},
  url = {https://www.freecodecamp.org/news/what-is-the-jamstack-and-how-do-i-host-my-website-on-it/},
  urldate = {2021-10-11},
  abstract = {JAMstack sites are all the rage right now in the web dev world. And rightfully so! But what exactly is it and how can we all take advantage of its benefits? What is this JAMstack?That's not to be confused with serverlessWhat makes up the JAMstack?So what makes},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/ZVGV3PFD/what-is-the-jamstack-and-how-do-i-host-my-website-on-it.html}
}

@incollection{freemanUnderstandingTypeScript2021,
  title = {Understanding {{TypeScript}}},
  booktitle = {Essential {{TypeScript}} 4: {{From Beginner}} to {{Pro}}},
  author = {Freeman, Adam},
  editor = {Freeman, Adam},
  year = {2021},
  pages = {35--41},
  publisher = {{Apress}},
  address = {{Berkeley, CA}},
  doi = {10.1007/978-1-4842-7011-0_2},
  url = {https://doi.org/10.1007/978-1-4842-7011-0_2},
  urldate = {2021-10-09},
  abstract = {TypeScript is a superset of the JavaScript language that focuses on producing safe and predictable code that can be executed by any JavaScript runtime. Its headline feature is static typing, which makes working with JavaScript more predictable for programmers familiar with languages such as C\# and Java. In this book, I explain what TypeScript does and describe the different features it provides.},
  isbn = {978-1-4842-7011-0},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/S6S3DMHH/Freeman - 2021 - Understanding TypeScript.pdf}
}

@incollection{gagliardiDjangoRESTMeets2021,
  title = {Django {{REST Meets Next}}.Js},
  booktitle = {Decoupled {{Django}}	: {{Understand}} and {{Build Decoupled Django Architectures}} for {{JavaScript Front-ends}}},
  author = {Gagliardi, Valentino},
  editor = {Gagliardi, Valentino},
  year = {2021},
  pages = {113--132},
  publisher = {{Apress}},
  address = {{Berkeley, CA}},
  doi = {10.1007/978-1-4842-7144-5_8},
  url = {https://doi.org/10.1007/978-1-4842-7144-5_8},
  abstract = {This chapter covers:},
  isbn = {978-1-4842-7144-5}
}

@article{gozneliIdentificationEvaluationProcess2020,
  title = {Identification and Evaluation of a Process for Transitioning from {{REST APIs}} to {{GRAPHQL APIs}} in the Context of Microservices Architecture},
  author = {G{\"o}zneli, Berke and Bondel, Gloria},
  year = {2020},
  pages = {20},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/2BTP8Q59/Gözneli and Bondel - Identification and evaluation of a process for tra.pdf}
}

@misc{GraphQL,
  title = {{{GraphQL}}},
  url = {https://book.hacktricks.xyz/pentesting/pentesting-web/graphql},
  urldate = {2021-10-09},
  file = {/Users/dieman/Zotero/storage/5JGGCW3G/graphql.html}
}

@misc{graphqlbypopSuppressingProblemGraphQL2020,
  title = {Suppressing the {{N}}+1 {{Problem}} | {{GraphQL}} by {{PoP}}},
  author = {{GraphQL by PoP}},
  year = {2020},
  url = {https://graphql-by-pop.com/docs/architecture/suppressing-n-plus-one-problem.html#what-is-the-n-1-problem},
  urldate = {2021-10-11},
  abstract = {CMS-agnostic GraphQL server in PHP},
  langid = {american},
  file = {/Users/dieman/Zotero/storage/EQC6N8MA/suppressing-n-plus-one-problem.html}
}

@misc{GraphQLDocumentationGenerators2019,
  title = {{{GraphQL Documentation Generators}}, {{Explorers}}, and {{Tools}} | {{Nordic APIs}} |},
  year = {2019},
  month = jul,
  journal = {Nordic APIs},
  url = {https://nordicapis.com/graphql-documentation-generators-explorers-and-tools/},
  urldate = {2022-03-19},
  abstract = {Automatically generating~documentation is a dream come true for developers looking to focus on the code instead of copywriting. It's also a dream for end users, who get documentation that's up-to-date and reliable. GraphQL is a popular query language that lets developers extract the information they need from APIs. Considering that there are over 21,000 public ...},
  langid = {american},
  file = {/Users/dieman/Zotero/storage/LMTWHTJQ/graphql-documentation-generators-explorers-and-tools.html}
}

@misc{gruber38MarkdownSyntax2020,
  title = {38 {{Markdown}}: {{Syntax}}},
  author = {Gruber, John},
  year = {2020},
  url = {http://scholar.googleusercontent.com/scholar?q=cache:VSqAlECcGQYJ:scholar.google.com/+markdown&hl=en&as_sdt=0,5},
  urldate = {2022-03-19},
  file = {/Users/dieman/Zotero/storage/C4P8P2K6/scholar.html}
}

@inproceedings{hartigDefiningSchemasProperty2019,
  title = {Defining {{Schemas}} for {{Property Graphs}} by Using the {{GraphQL Schema Definition Language}}},
  author = {Hartig, Olaf and Hidders, Jan},
  year = {2019},
  month = jun,
  pages = {1--11},
  doi = {10.1145/3327964.3328495},
  abstract = {GraphQL is a highly popular new approach to build Web APIs. An important component of this approach is the GraphQL schema definition language (SDL). The original purpose of this language is to define a so-called GraphQL schema that specifies the types of objects that can be queried when accessing a specific GraphQL Web API. This paper focuses on the question: Can we repurpose this language to define schemas for graph databases that are based on the Property Graph model? This question is relevant because there does not exist a commonly adopted approach to define schemas for Property Graphs, and because the form in which GraphQL APIs represent their underlying data sources is very similar to the Property Graph model. To answer the question we propose an approach to adopt the GraphQL SDL for Property Graph schemas. We define this approach formally and show its fundamental properties.},
  file = {/Users/dieman/Zotero/storage/LK9QYR65/Hartig and Hidders - 2019 - Defining Schemas for Property Graphs by using the .pdf}
}

@article{hartigInitialAnalysisFacebook2017,
  title = {An {{Initial Analysis}} of {{Facebook}}'s {{GraphQL Language}}},
  author = {Hartig, Olaf and P{\'e}rez, Jorge},
  year = {2017},
  pages = {10},
  abstract = {Facebook's GraphQL is a recently proposed, and increasingly adopted, conceptual framework for providing a new type of data access interface on the Web. The framework includes a new graph query language whose semantics has been specified informally only. The goal of this paper is to understand the properties of this language. To this end, we first provide a formal query semantics. Thereafter, we analyze the language and show that it has a very low complexity for evaluation. More specifically, we show that the combined complexity of the main decision problems is in NL (Nondeterministic Logarithmic Space) and, thus, they can be solved in polynomial time and are highly parallelizable.},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/E4UFB4MW/Hartig and Pérez - An Initial Analysis of Facebook’s GraphQL Language.pdf}
}

@incollection{helmoldLeanManagementKPI2020,
  title = {Lean {{Management KPI}} and {{OKR}}},
  booktitle = {Lean {{Management}} and {{Kaizen}}: {{Fundamentals}} from {{Cases}} and {{Examples}} in {{Operations}} and {{Supply Chain Management}}},
  author = {Helmold, Marc},
  editor = {Helmold, Marc},
  year = {2020},
  series = {Management for {{Professionals}}},
  pages = {113--122},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-46981-8_12},
  url = {https://doi.org/10.1007/978-3-030-46981-8_12},
  urldate = {2021-10-09},
  abstract = {Lean management must be an integral part of any enterprise and organization. Performance improvements and permanent adjustments are important factors for the successful implementation of lean structures. Performance management therefore integrates a cycle from performance measurement and analysis (Plan), the performance action and implementation (Do), the performance management controlling (Check), and the performance improvements and adjustments (Act) as illustrated in the lean performance management cycle in Fig. 12.1. The figure shows the lean performance management cycle as an iterative and continuous process for the control and improvement of processes, products, or services. The original P-D-C-A four-step framework is also known as Deming circle (Slack 1995).},
  isbn = {978-3-030-46981-8},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/APISSDVG/Helmold - 2020 - Lean Management KPI and OKR.pdf}
}

@misc{hexdocsOverviewAbsintheV12022,
  title = {Overview \textemdash{} Absinthe v1.7.0},
  author = {Hexdocs},
  year = {2022},
  url = {https://hexdocs.pm/absinthe/overview.html},
  urldate = {2022-03-19},
  file = {/Users/dieman/Zotero/storage/PYATFJJV/overview.html}
}

@misc{howtographqlGraphQLVsREST2021,
  title = {{{GraphQL}} vs {{REST}} - {{A}} Comparison},
  author = {HowToGraphQL},
  year = {2021},
  url = {https://www.howtographql.com/basics/1-graphql-is-the-better-rest/},
  urldate = {2022-03-19},
  abstract = {Learn why GraphQL is a more efficient and flexible alternative to REST APIs. It has a strong type system and avoids frontend issues like over- and underfetching.},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/PIQ7T6JD/1-graphql-is-the-better-rest.html}
}

@misc{karthicDesigningGraphQLSchemas2020,
  title = {Designing {{GraphQL}} Schemas - {{Dgraph Blog}}},
  author = {Karthic, Rao},
  year = {2020},
  url = {https://dgraph.io/blog/post/designing-graphql-schemas/},
  urldate = {2022-03-19},
  file = {/Users/dieman/Zotero/storage/2ZBL5FEU/designing-graphql-schemas.html}
}

@misc{khalilWhyYouShould2021,
  title = {Why {{You Should Disable GraphQL Introspection In Production}} \textendash{} {{GraphQL Security}}},
  author = {Khalil, Stemmler},
  year = {2021},
  journal = {Apollo GraphQL Blog},
  url = {https://www.apollographql.com/blog/graphql/security/why-you-should-disable-graphql-introspection-in-production/},
  urldate = {2021-10-09},
  abstract = {Once your graph is up and running in production, like anything else on the internet, it's a good idea to implement precautions to prevent it from being compromised by bad actors. Disabling introspection in production is a widely debated topic, but we believe it's one of the first things you can do to harden your [\ldots ]},
  file = {/Users/dieman/Zotero/storage/J9H2TXAN/why-you-should-disable-graphql-introspection-in-production.html}
}

@inproceedings{korenExploitationOpenAPIDocumentation2018,
  title = {The Exploitation of {{OpenAPI}} Documentation for the Generation of Web Frontends},
  booktitle = {Companion Proceedings of the the Web Conference 2018},
  author = {Koren, Istv{\'a}n and Klamma, Ralf},
  year = {2018},
  publisher = {{International World Wide Web Conferences Steering Committee}},
  doi = {10.1145/3184558.3188740},
  url = {https://doi.org/10.1145/3184558.3188740},
  abstract = {New Internet-enabled devices and Web services are introduced on a daily basis. Documentation formats are available that describe their functionalities in terms of API endpoints and parameters. In particular, the OpenAPI specification has gained considerable influence over the last years. Web-based solutions exist that generate interactive OpenAPI documentation with HTML5 \&amp; JavaScript. They allow developers to quickly get an understanding what the services and devices do and how they work. However, the generated user interfaces are far from real-world practices of designers and end users. We present an approach to overcome this gap, by using a model-driven methodology resulting in state-of-the-art responsive Web user interfaces. To this end, we use the Interaction Flow Modeling Language (IFML) as intermediary model specification to bring together APIs and frontends. Our implementation is based on open standards like Web Components and SVG. A screencast of our tool is available at https://youtu.be/KFOPmPShak4},
  isbn = {978-1-4503-5640-4}
}

@inproceedings{kouraiSecureOffloadingLegacy2016,
  title = {Secure {{Offloading}} of {{Legacy IDSes Using Remote VM Introspection}} in {{Semi-trusted Clouds}}},
  booktitle = {2016 {{IEEE}} 9th {{International Conference}} on {{Cloud Computing}} ({{CLOUD}})},
  author = {Kourai, Kenichi and Juda, Kazuki},
  year = {2016},
  month = jun,
  pages = {43--50},
  issn = {2159-6190},
  doi = {10.1109/CLOUD.2016.0016},
  abstract = {In Infrastructure-as-a-Service (IaaS) clouds, intrusion detection systems (IDSes) increase their importance. To securely detect attacks against virtual machines (VMs), IDS offloading with VM introspection (VMI) has been proposed. In semi-trusted clouds, however, it is difficult to securely offload IDSes because there may exist insiders such as malicious system administrators. First, secure VM execution cannot coexist with IDS offloading although it has to be enabled to prevent information leakage to insiders. Second, offloaded IDSes can be easily disabled by insiders. To solve these problems, this paper proposes IDS remote offloading with remote VMI. Since IDSes can run at trusted remote hosts outside semi-trusted clouds, they cannot be disabled by insiders in clouds. Remote VMI enables IDSes at remote hosts to introspect VMs via the trusted hypervisor inside semi-trusted clouds. Secure VM execution can be bypassed by performing VMI in the hypervisor. Remote VMI preserves the integrity and confidentiality of introspected data between the hypervisor and remote hosts. The integrity of the hypervisor can be guaranteed by various existing techniques. We have developed RemoteTrans for remotely offloading legacy IDSes and confirmed that RemoteTrans could achieve surprisingly efficient execution of legacy IDSes at remote hosts.},
  keywords = {Cloud computing,clouds,Cryptography,Engines,IDS,insider attacks,Memory management,Runtime,Servers,Virtual machine monitors,VMI,VMs},
  file = {/Users/dieman/Zotero/storage/EDZE3CZ3/7820253.html}
}

@article{lawiEvaluatingGraphQLREST2021,
  title = {Evaluating {{GraphQL}} and {{REST API Services Performance}} in a {{Massive}} and {{Intensive Accessible Information System}}},
  author = {Lawi, Armin and Panggabean, Benny L. E. and Yoshida, Takaichi},
  year = {2021},
  month = sep,
  publisher = {{Preprints}},
  doi = {10.20944/preprints202109.0386.v1},
  url = {https://www.preprints.org/manuscript/202109.0386/v1},
  urldate = {2022-03-24},
  abstract = {Currently, most middleware application developers have two choices when designing or implementing API services: They can either stick with REST or explore the emerging GraphQL technology. Although REST is widely considered the standard method for API development, GraphQL is believed to overcome the main drawbacks of REST, especially data fetching issues. Yet, doubts remain as there are no experimental studies with convincing results to evaluate the performance of the two services. In this paper, we propose a research methodology to evaluate the performance of REST and GraphQL API services, which includes two main contributions. The first contribution is that the performance evaluation of the two services is conducted in the real operation of a massive and intensively accessible management information system. The second contribution is the fair and independent performance evaluation results obtained for both API services. The performance evaluation was studied using basic measures of QoS, including response time, throughput, CPU load, and memory usage. The results show that REST is still faster in response time and throughput, while GraphQL is very efficient in resource utilization, i.e., CPU load and memory utilization. Therefore, GraphQL is the right choice when data requirements change frequently and resource utilization is the most important consideration. REST is used when some data is frequently accessed called by multiple requests.},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/VWUS2R98/Lawi et al. - 2021 - Evaluating GraphQL and REST API Services Performan.pdf;/Users/dieman/Zotero/storage/D5JAJX9J/v1.html}
}

@misc{legislation.gov.ukDataProtectionAct2022,
  type = {Text},
  title = {Data {{Protection Act}} 1998},
  author = {Legislation.gov.uk},
  year = {2022},
  month = jan,
  publisher = {{Statute Law Database}},
  url = {https://www.legislation.gov.uk/ukpga/1998/29/contents},
  urldate = {2022-03-19},
  abstract = {An Act to make new provision for the regulation of the processing of information relating to individuals, including the obtaining, holding, use or disclosure of such information.},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/TFSBM3IL/contents.html}
}

@article{pratapyadavFormalApproachDocker2021,
  title = {A Formal Approach for {{Docker}} Container Deployment},
  author = {Pratap Yadav, Mahendra and Pal, Nisha and Kumar Yadav, Dharmendra},
  year = {2021},
  journal = {Concurrency and Computation: Practice and Experience},
  volume = {33},
  number = {20},
  pages = {e6364},
  issn = {1532-0634},
  doi = {10.1002/cpe.6364},
  url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/cpe.6364},
  urldate = {2021-10-09},
  abstract = {Container-based virtualization is becoming increasingly popular in the cloud industry, as it provides services to the client as per their requirements. Requirements of the user can be described in a configuration file. Cloud provider offers the services to the client using ``pay-as-you go'' model. Docker provides support to a cloud provider for the creation of a container, deployment of the container, and monitoring of services running inside a container on the host and guest system both. The creation and deployment of the container by Docker efficiently is a big challenge. In this paper, we capture the behavior of the container life cycle through process algebra (CCS) and properties of it as a formula using -calculus. Further we capture the behavior of deployment of the container on the host machine through CCS and its properties through the model - calculus. We used model checking tool Concurrency Workbench of the New Century to verify the creation of the Docker container as well as deployment of it.},
  langid = {english},
  keywords = {CCS,cloud computing,container,Docker,formal methods,virtualization},
  annotation = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/cpe.6364},
  file = {/Users/dieman/Zotero/storage/3MRD5MK5/Pratap Yadav et al. - 2021 - A formal approach for Docker container deployment.pdf;/Users/dieman/Zotero/storage/SLNE32PP/cpe.html}
}

@misc{rizwanGraphQLCommonVulnerabilities2021,
  title = {{{GraphQL}} \textemdash{} {{Common}} Vulnerabilities \& How to Exploit Them},
  author = {Rizwan, Bilal},
  year = {2021},
  month = feb,
  journal = {Medium},
  url = {https://the-bilal-rizwan.medium.com/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696},
  urldate = {2021-10-09},
  abstract = {Hello there! how you doin?~, Bilal Rizwan here \& I hope everyone is safe in this time of crisis and making complete use of your\ldots},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/6CGRL9PS/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696.html}
}

@inproceedings{seabraRESTGraphQLPerformance2019,
  title = {{{REST}} or {{GraphQL}}? {{A Performance Comparative Study}}},
  shorttitle = {{{REST}} or {{GraphQL}}?},
  booktitle = {Proceedings of the {{XIII Brazilian Symposium}} on {{Software Components}}, {{Architectures}}, and {{Reuse}}},
  author = {Seabra, Matheus and Naz{\'a}rio, Marcos Felipe and Pinto, Gustavo},
  year = {2019},
  month = sep,
  series = {{{SBCARS}} '19},
  pages = {123--132},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3357141.3357149},
  url = {https://doi.org/10.1145/3357141.3357149},
  urldate = {2022-03-19},
  abstract = {Given the variety of architectural models that can be used, a frequent questioning among software development practitioners is: which architectural model to use? To respond this question regarding performance issues, three target applications have been studied, each written using two models web services architectures: REST and GraphQL. Through research of performance metrics of response time and the average transfer rate between the requests, it was possible to deduce the particularities of each architectural model in terms of performance metrics. It was observed that migrating to GraphQL. resulted in an increase in performance in two-thirds of the tested applications, with respect to average number of requests per second and transfer rate of data. However, it was noticed that services after migration for GraphQL performed below its REST counterpart for workloads above 3000 requests, ranging from 98 to 2159 Kbytes per second after the migration study. On the other hand, for more trivial workloads, services on both REST and GraphQL architectures presented similar performances, where values between REST and GraphQL services ranged from 6.34 to 7.68 requests per second for workloads of 100 requests.},
  isbn = {978-1-4503-7637-2},
  keywords = {GraphQL,Modelo arquitetural,REST,Teste de desempenho},
  file = {/Users/dieman/Zotero/storage/NRDMELIL/Seabra et al. - 2019 - REST or GraphQL A Performance Comparative Study.pdf}
}

@book{soniEndEndAutomation2015,
  title = {End to {{End Automation}} on {{Cloud}} with {{Build Pipeline}}: {{The Case}} for {{DevOps}} in {{Insurance Industry}}, {{Continuous Integration}}, {{Continuous Testing}}, and {{Continuous Delivery}}},
  shorttitle = {2015 {{IEEE International Conference}} on {{Cloud Computing}} in {{Emerging Markets}} 25-27 {{November}} 2015, {{Bangalore}}, {{India}}},
  author = {Soni, Mitesh},
  year = {2015},
  url = {https://ieeexplore.ieee.org/document/7436936},
  urldate = {2021-10-06},
  isbn = {978-1-4673-8566-4},
  langid = {english},
  annotation = {OCLC: 956701216}
}

@misc{stablekernelAdvantagesDisadvantagesGraphQL2021,
  title = {Advantages and {{Disadvantages}} of {{GraphQL}} | {{Stable Kernel}}},
  author = {Stable Kernel},
  year = {2021},
  url = {https://stablekernel.com/article/advantages-and-disadvantages-of-graphql/},
  urldate = {2022-03-20},
  file = {/Users/dieman/Zotero/storage/3U5ZXY46/advantages-and-disadvantages-of-graphql.html}
}

@misc{stefanReasonsWhyWent2018,
  title = {3 Reasons Why {{I}} Went Framework Agnostic and Why You Should Do That Too | by {{Stefan Nieuwenhuis}} | {{Medium}}},
  author = {Stefan, Nieuwenhuis},
  year = {2018},
  url = {https://stefannhs.medium.com/3-reasons-why-i-went-framework-agnostic-and-why-you-should-do-that-too-f39ba81c6001},
  urldate = {2022-03-19},
  file = {/Users/dieman/Zotero/storage/H6IE3S5V/3-reasons-why-i-went-framework-agnostic-and-why-you-should-do-that-too-f39ba81c6001.html}
}

@inproceedings{taelmanGraphQLLDLinkedData2018,
  title = {{{GraphQL-LD}}: {{Linked Data Querying}} with {{GraphQL}}},
  shorttitle = {{{GraphQL-LD}}},
  booktitle = {{{SEMWEB}}},
  author = {Taelman, Ruben and Sande, M. V. and Verborgh, R.},
  year = {2018},
  abstract = {Semantic Scholar extracted view of "GraphQL-LD: Linked Data Querying with GraphQL" by Ruben Taelman et al.}
}

@misc{theagilehelpScrumVsKanban2020,
  title = {Scrum vs {{Kanban}}: Which One to Choose and Why? \textendash{} {{TheAgileHelp}}},
  shorttitle = {Scrum vs {{Kanban}}},
  author = {TheAgileHelp},
  year = {2020},
  url = {https://www.theagilehelp.com/scrum-vs-kanban-which-one-to-choose-and-why/},
  urldate = {2021-10-11},
  langid = {american},
  file = {/Users/dieman/Zotero/storage/LAMEXZHU/scrum-vs-kanban-which-one-to-choose-and-why.html}
}

@inproceedings{vadlamaniCanGraphQLReplace2021,
  title = {Can {{GraphQL Replace REST}}? {{A Study}} of {{Their Efficiency}} and {{Viability}}},
  shorttitle = {Can {{GraphQL Replace REST}}?},
  booktitle = {2021 {{IEEE}}/{{ACM}} 8th {{International Workshop}} on {{Software Engineering Research}} and {{Industrial Practice}} ({{SER IP}})},
  author = {Vadlamani, Sri Lakshmi and Emdon, Benjamin and Arts, Joshua and Baysal, Olga},
  year = {2021},
  month = jun,
  pages = {10--17},
  doi = {10.1109/SER-IP52554.2021.00009},
  abstract = {Representational State Transfer (REST) has traditionally been the standard web service architectural style for API creation. However, its popularity has been challenged with the introduction of GraphQL, an open source query language for APIs introduced by Facebook, in 2015. The latter has been quickly adopted by GitHub, Shopify, Airbnb, Twitter and more online portals are joining the list. In some instances, GraphQL has been adopted as an alternative architectural style or has been used in conjunction with REST.While GraphQL promises a considerable improvement over REST, much remains unexplored with respect to its efficiency and feasibility in its application. The goal of this paper is to determine viability of using GraphQL over REST for API architecture from quantitative and qualitative perspectives. A custom API client on GitHub is constructed to check on the response times and the corresponding magnitude of difference between REST and GraphQL. Thereafter, the paper surveyed employees of GitHub to understand software developers' educated opinion and perceptions about REST and GraphQL based on their practical experience with APIs. The results show that both API paradigms have their benefits and weaknesses, and one cannot replace the other, at least in the near future.},
  keywords = {adoption,APIs,Computer architecture,developer perspective,efficiency,GraphQL,Representational state transfer,REST,Social networking (online),Software,survey,Time factors,Time measurement,viability,Web services},
  file = {/Users/dieman/Zotero/storage/GFFYYV6G/9474834.html}
}

@incollection{vogelExperiencesMigratingRESTful2018,
  title = {Experiences on {{Migrating RESTful Web Services}} to {{GraphQL}}},
  author = {Vogel, Maximilian and Weber, Sebastian and Zirpins, Christian},
  year = {2018},
  month = jun,
  pages = {283--295},
  doi = {10.1007/978-3-319-91764-1_23},
  abstract = {Web service APIs are central hubs of modern cloud-based application systems. Over recent years, REST has become a de facto standard for their architectural style. Yet in scenarios like mobile apps, flexible client-centric data fetching approaches have emerged as a promising alternative. This gives rise to the question whether RESTful systems can be migrated to a technique like GraphQL and benefit from the new approach. In this paper we report on our experiences during such migration of a real world smart home application. Our observations have underpinned some of the conceptual benefits but also identified challenging aspects where further research is required.},
  isbn = {978-3-319-91763-4}
}

@inproceedings{witternEmpiricalStudyGraphQL2019,
  title = {An {{Empirical Study}} of {{GraphQL Schemas}}},
  booktitle = {Service-{{Oriented Computing}}},
  author = {Wittern, Erik and Cha, Alan and Davis, James C. and Baudart, Guillaume and Mandel, Louis},
  editor = {Yangui, Sami and Bouassida Rodriguez, Ismael and Drira, Khalil and Tari, Zahir},
  year = {2019},
  pages = {3--19},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  url = {https://link.springer.com/chapter/10.1007/978-3-319-91662-0_5},
  abstract = {GraphQL is a query language for APIs and a runtime to execute queries. Using GraphQL queries, clients define precisely what data they wish to retrieve or mutate on a server, leading to fewer round trips and reduced response sizes. Although interest in GraphQL is on the rise, with increasing adoption at major organizations, little is known about what GraphQL interfaces look like in practice. This lack of knowledge makes it hard for providers to understand what practices promote idiomatic, easy-to-use APIs, and what pitfalls to avoid.},
  isbn = {978-3-030-33702-5}
}

@inproceedings{witternGeneratingGraphQLWrappersREST2018,
  title = {Generating {{GraphQL-Wrappers}} for {{REST}}(-like) {{APIs}}},
  booktitle = {Web {{Engineering}}},
  author = {Wittern, Erik and Cha, Alan and Laredo, Jim A.},
  editor = {Mikkonen, Tommi and Klamma, Ralf and Hern{\'a}ndez, Juan},
  year = {2018},
  pages = {65--83},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  abstract = {GraphQL is a query language and thereupon-based paradigm for implementing web Application Programming Interfaces (APIs) for client-server interactions. Using GraphQL, clients define precise, nested data-requirements in typed queries, which are resolved by servers against (possibly multiple) backend systems, like databases, object storages, or other APIs. Clients receive only the data they care about, in a single request. However, providers of existing REST(-like) APIs need to implement additional GraphQL interfaces to enable these advantages. We here assess the feasibility of automatically generating GraphQL wrappers for existing REST(-like) APIs. A wrapper, upon receiving GraphQL queries, translates them to requests against the target API. We discuss the challenges for creating such wrappers, including dealing with data sanitation, authentication, or handling nested queries. We furthermore present a prototypical implementation of OASGraph. OASGraph takes as input an OpenAPI Specification (OAS) describing an existing REST(-like) web API and generates a GraphQL wrapper for it. We evaluate OASGraph by running it, as well as an existing open source alternative, against 959 publicly available OAS. This experiment shows that OASGraph outperforms the existing alternative and is able to create a GraphQL wrapper for \$\$89.5\textbackslash\%\$\$of the APIs \textendash{} however, with limitations in many cases. A subsequent analysis of errors and warnings produced by OASGraph shows that missing or ambiguous information in the assessed OAS hinders creating complete wrappers. Finally, we present a use case of the IBM Watson Language Translator API that shows that small changes to an OAS allow OASGraph to generate more idiomatic and more expressive GraphQL wrappers.},
  isbn = {978-3-319-91662-0}
}

@misc{yeswehackHowExploitGraphQL2021,
  title = {How to Exploit {{GraphQL}} Endpoint: Introspection, Query, Mutations \& Tools},
  shorttitle = {How to Exploit {{GraphQL}} Endpoint},
  author = {YesWeHack},
  year = {2021},
  month = mar,
  journal = {Global Bug Bounty Platform},
  url = {https://blog.yeswehack.com/yeswerhackers/how-exploit-graphql-endpoint-bug-bounty/},
  urldate = {2021-10-09},
  abstract = {How to exploit a GraphQL endpoint. How to perform Introspection and Mutations? Learn more about tools, bathing attacks, fuzzing and IDORs!},
  langid = {american},
  file = {/Users/dieman/Zotero/storage/2YKFW8AM/how-exploit-graphql-endpoint-bug-bounty.html}
}

@article{yuUtilisingCIEnvironment2020,
  title = {Utilising {{CI}} Environment for Efficient and Effective Testing of {{NFRs}}},
  author = {Yu, Liang and Al{\'e}groth, Emil and Chatzipetrou, Panagiota and Gorschek, Tony},
  year = {2020},
  month = jan,
  journal = {Information and Software Technology},
  volume = {117},
  pages = {106199},
  issn = {0950-5849},
  doi = {10.1016/j.infsof.2019.106199},
  url = {https://www.sciencedirect.com/science/article/pii/S095058491930206X},
  urldate = {2021-10-09},
  abstract = {Context Continuous integration (CI) is a practice that aims to continuously verify quality aspects of a software intensive system both for functional and non-functional requirements (NFRs). Functional requirements are the inputs of development and can be tested in isolation, utilising either manual or automated tests. In contrast, some NFRs are difficult to test without functionality, for NFRs are often aspects of functionality and express quality aspects. Lacking this testability attribute makes NFR testing complicated and, therefore, underrepresented in industrial practice. However, the emergence of CI has radically affected software development and created new avenues for software quality evaluation and quality information acquisition. Research has, consequently, been devoted to the utilisation of this additional information for more efficient and effective NFR verification. Objective We aim to identify the state-of-the-art of utilising the CI environment for NFR testing, hereinafter referred to as CI-NFR testing. Method Through rigorous selection, from an initial set of 747 papers, we identified 47 papers that describe how NFRs are tested in a CI environment. Evidence-based analysis, through coding, is performed on the identified papers in this SLR. Results Firstly, ten CI approaches are described by the papers selected, each describing different tools and nine different NFRs where reported to be tested. Secondly, although possible, CI-NFR testing is associated with eight challenges that adversely affect its adoption. Thirdly, the identified CI-NFR testing processes are tool-driven, but there is a lack of NFR testing tools that can be used in the CI environment. Finally, we proposed a CI framework for NFRs testing. Conclusion A synthesised CI framework is proposed for testing various NFRs, and associated CI tools are also mapped. This contribution is valuable as results of the study also show that CI-NFR testing can help improve the quality of NFR testing in practices.},
  langid = {english},
  keywords = {Agile,CI,Continuous integration,DevOps,NFR,Non-functional requirement,SAFe,Scaled agile framework},
  file = {/Users/dieman/Zotero/storage/D5MCR22Y/S095058491930206X.html}
}

@incollection{zammettiWhatJAMstackAll2020,
  title = {What {{Is JAMstack All About}}?},
  booktitle = {Practical {{JAMstack}}: {{Blazing Fast}}, {{Simple}}, and {{Secure Web Development}}, the {{Modern Way}}},
  author = {Zammetti, Frank},
  editor = {Zammetti, Frank},
  year = {2020},
  pages = {1--17},
  publisher = {{Apress}},
  address = {{Berkeley, CA}},
  doi = {10.1007/978-1-4842-6177-4_1},
  url = {https://doi.org/10.1007/978-1-4842-6177-4_1},
  urldate = {2021-10-09},
  abstract = {Welcome, dear reader, to the book!},
  isbn = {978-1-4842-6177-4},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/223YYP6A/Zammetti - 2020 - What Is JAMstack All About.pdf}
}

@article{zayatFrameworkStudyAgile2020,
  title = {Framework {{Study}} for {{Agile Software Development Via Scrum}} and {{Kanban}}},
  author = {Zayat, Wael and Senvar, Ozlem},
  year = {2020},
  month = jun,
  journal = {International Journal of Innovation and Technology Management},
  volume = {17},
  number = {04},
  pages = {2030002},
  publisher = {{World Scientific Publishing Co.}},
  issn = {0219-8770},
  doi = {10.1142/S0219877020300025},
  url = {https://www.worldscientific.com/doi/epdf/10.1142/S0219877020300025},
  urldate = {2021-10-06},
  abstract = {This paper provides a systematic comparison between two well-known Agile methodologies: Scrum, which is a framework of doing projects by allocating tasks into small stages called sprints, and Kanban, which is a scheduling system to manage the flow of work by means of visual signals. In this regard, both methodologies were reviewed to explore similarities and differences between them. Then, a focus group survey was performed to specify the preferable methodology for product development according to various parameters in the project environment including project complexity, level of uncertainty, and work size with consideration of output factors like quality, productivity, and delivery. Results show the flexibility of both methodologies in approaching Agile objectives, where Scrum emphasizes on the corporation of the customer and development teams with a focus on particular skills such as planning, organization, presentation, and reviewing which makes it ideal for new and complex projects where a regular involvement of the customer is required, whereas Kanban is more operative in continuous-flow environments with a steady approach toward a system improvement.},
  note = {doi: 10.1142/S0219877020300025}
}


