
@inproceedings{korenExploitationOpenAPIDocumentation2018,
  title = {The Exploitation of {{OpenAPI}} Documentation for the Generation of Web Frontends},
  booktitle = {Companion Proceedings of the the Web Conference 2018},
  author = {Koren, Istv{\'a}n and Klamma, Ralf},
  year = {2018},
  publisher = {{International World Wide Web Conferences Steering Committee}},
  doi = {10.1145/3184558.3188740},
  url = {https://doi.org/10.1145/3184558.3188740},
  abstract = {New Internet-enabled devices and Web services are introduced on a daily basis. Documentation formats are available that describe their functionalities in terms of API endpoints and parameters. In particular, the OpenAPI specification has gained considerable influence over the last years. Web-based solutions exist that generate interactive OpenAPI documentation with HTML5 \&amp; JavaScript. They allow developers to quickly get an understanding what the services and devices do and how they work. However, the generated user interfaces are far from real-world practices of designers and end users. We present an approach to overcome this gap, by using a model-driven methodology resulting in state-of-the-art responsive Web user interfaces. To this end, we use the Interaction Flow Modeling Language (IFML) as intermediary model specification to bring together APIs and frontends. Our implementation is based on open standards like Web Components and SVG. A screencast of our tool is available at https://youtu.be/KFOPmPShak4},
  isbn = {978-1-4503-5640-4}
}

@book{soniEndEndAutomation2015,
  title = {End to {{End Automation}} on {{Cloud}} with {{Build Pipeline}}: The {{Case}} for {{DevOps}} in {{Insurance Industry}}, {{Continuous Integration}}, {{Continuous Testing}}, and {{Continuous Delivery}}},
  shorttitle = {2015 {{IEEE International Conference}} on {{Cloud Computing}} in {{Emerging Markets}} 25-27 {{November}} 2015, {{Bangalore}}, {{India}}},
  author = {Soni, Mitesh},
  year = {2015},
  url = {https://ieeexplore.ieee.org/document/7436936},
  urldate = {2021-10-06},
  isbn = {978-1-4673-8566-4},
  langid = {english},
  annotation = {OCLC: 956701216}
}

@inproceedings{witternEmpiricalStudyGraphQL2019a,
  title = {An {{Empirical Study}} of {{GraphQL Schemas}}},
  booktitle = {Service-{{Oriented Computing}}},
  author = {Wittern, Erik and Cha, Alan and Davis, James C. and Baudart, Guillaume and Mandel, Louis},
  editor = {Yangui, Sami and Bouassida Rodriguez, Ismael and Drira, Khalil and Tari, Zahir},
  year = {2019},
  pages = {3--19},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  url = {https://link.springer.com/chapter/10.1007/978-3-319-91662-0_5},
  abstract = {GraphQL is a query language for APIs and a runtime to execute queries. Using GraphQL queries, clients define precisely what data they wish to retrieve or mutate on a server, leading to fewer round trips and reduced response sizes. Although interest in GraphQL is on the rise, with increasing adoption at major organizations, little is known about what GraphQL interfaces look like in practice. This lack of knowledge makes it hard for providers to understand what practices promote idiomatic, easy-to-use APIs, and what pitfalls to avoid.},
  isbn = {978-3-030-33702-5}
}

@inproceedings{witternGeneratingGraphQLWrappersREST2018,
  title = {Generating {{GraphQL}}-{{Wrappers}} for {{REST}}(-like) {{APIs}}},
  booktitle = {Web {{Engineering}}},
  author = {Wittern, Erik and Cha, Alan and Laredo, Jim A.},
  editor = {Mikkonen, Tommi and Klamma, Ralf and Hern{\'a}ndez, Juan},
  year = {2018},
  pages = {65--83},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  abstract = {GraphQL is a query language and thereupon-based paradigm for implementing web Application Programming Interfaces (APIs) for client-server interactions. Using GraphQL, clients define precise, nested data-requirements in typed queries, which are resolved by servers against (possibly multiple) backend systems, like databases, object storages, or other APIs. Clients receive only the data they care about, in a single request. However, providers of existing REST(-like) APIs need to implement additional GraphQL interfaces to enable these advantages. We here assess the feasibility of automatically generating GraphQL wrappers for existing REST(-like) APIs. A wrapper, upon receiving GraphQL queries, translates them to requests against the target API. We discuss the challenges for creating such wrappers, including dealing with data sanitation, authentication, or handling nested queries. We furthermore present a prototypical implementation of OASGraph. OASGraph takes as input an OpenAPI Specification (OAS) describing an existing REST(-like) web API and generates a GraphQL wrapper for it. We evaluate OASGraph by running it, as well as an existing open source alternative, against 959 publicly available OAS. This experiment shows that OASGraph outperforms the existing alternative and is able to create a GraphQL wrapper for \$\$89.5\textbackslash\%\$\$of the APIs \textendash{} however, with limitations in many cases. A subsequent analysis of errors and warnings produced by OASGraph shows that missing or ambiguous information in the assessed OAS hinders creating complete wrappers. Finally, we present a use case of the IBM Watson Language Translator API that shows that small changes to an OAS allow OASGraph to generate more idiomatic and more expressive GraphQL wrappers.},
  isbn = {978-3-319-91662-0}
}

@article{zayatFrameworkStudyAgile2020,
  title = {Framework {{Study}} for {{Agile Software Development Via Scrum}} and {{Kanban}}},
  author = {Zayat, Wael and Senvar, Ozlem},
  year = {2020},
  month = jun,
  journal = {International Journal of Innovation and Technology Management},
  volume = {17},
  number = {04},
  pages = {2030002},
  publisher = {{World Scientific Publishing Co.}},
  issn = {0219-8770},
  doi = {10.1142/S0219877020300025},
  url = {https://www.worldscientific.com/doi/epdf/10.1142/S0219877020300025},
  urldate = {2021-10-06},
  abstract = {This paper provides a systematic comparison between two well-known Agile methodologies: Scrum, which is a framework of doing projects by allocating tasks into small stages called sprints, and Kanban, which is a scheduling system to manage the flow of work by means of visual signals. In this regard, both methodologies were reviewed to explore similarities and differences between them. Then, a focus group survey was performed to specify the preferable methodology for product development according to various parameters in the project environment including project complexity, level of uncertainty, and work size with consideration of output factors like quality, productivity, and delivery. Results show the flexibility of both methodologies in approaching Agile objectives, where Scrum emphasizes on the corporation of the customer and development teams with a focus on particular skills such as planning, organization, presentation, and reviewing which makes it ideal for new and complex projects where a regular involvement of the customer is required, whereas Kanban is more operative in continuous-flow environments with a steady approach toward a system improvement.}
}


