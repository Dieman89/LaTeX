
@inproceedings{britoRESTVsGraphQL2020,
  title = {{{REST}} vs {{GraphQL}}: {{A Controlled Experiment}}},
  shorttitle = {{{REST}} vs {{GraphQL}}},
  booktitle = {2020 {{IEEE International Conference}} on {{Software Architecture}} ({{ICSA}})},
  author = {Brito, Gleison and Valente, Marco Tulio},
  year = {2020},
  month = mar,
  pages = {81--91},
  doi = {10.1109/ICSA47634.2020.00016},
  abstract = {GraphQL is a novel query language for implementing service-based software architectures. The language is gaining momentum and it is now used by major software companies, such as Facebook and GitHub. However, we still lack empirical evidence on the real gains achieved by GraphQL, particularly in terms of the effort required to implement queries in this language. Therefore, in this paper we describe a controlled experiment with 22 students (10 undergraduate and 12 graduate), who were asked to implement eight queries for accessing a web service, using GraphQL and REST. Our results show that GraphQL requires less effort to implement remote service queries when compared to REST (9 vs 6 minutes, median times). These gains increase when REST queries include more complex endpoints, with several parameters. Interestingly, GraphQL outperforms REST even among more experienced participants (as is the case of graduate students) and among participants with previous experience in REST, but no previous experience in GraphQL.},
  keywords = {Database languages,Facebook,GraphQL,REST,Servers,Standards,Task analysis,Uniform resource locators,Web APIs,Web services},
  file = {/Users/dieman/Zotero/storage/9Q6FIMH5/Brito and Valente - 2020 - REST vs GraphQL A Controlled Experiment.pdf;/Users/dieman/Zotero/storage/NPGE8KS4/9101226.html}
}

@article{fanWhyAPIDocumentation2021,
  title = {Why {{API}} Documentation Is Insufficient for Developers: An Empirical Study},
  shorttitle = {Why {{API}} Documentation Is Insufficient for Developers},
  author = {Fan, Qiang and Yu, Yue and Wang, Tao and Yin, Gang and Wang, Huaimin},
  year = {2021},
  month = jan,
  journal = {Science China Information Sciences},
  volume = {64},
  number = {1},
  pages = {119102},
  issn = {1674-733X, 1869-1919},
  doi = {10.1007/s11432-019-9880-8},
  url = {http://link.springer.com/10.1007/s11432-019-9880-8},
  urldate = {2021-10-09},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/AHAAF7QW/Fan et al. - 2021 - Why API documentation is insufficient for develope.pdf}
}

@misc{freecodecampWhatJAMstackHow2020,
  title = {What Is the {{JAMstack}} and How Do {{I}} Get Started?},
  author = {{freeCodeCamp}},
  year = {2020},
  month = feb,
  journal = {freeCodeCamp.org},
  url = {https://www.freecodecamp.org/news/what-is-the-jamstack-and-how-do-i-host-my-website-on-it/},
  urldate = {2021-10-11},
  abstract = {JAMstack sites are all the rage right now in the web dev world. And rightfully so! But what exactly is it and how can we all take advantage of its benefits? What is this JAMstack?That's not to be confused with serverlessWhat makes up the JAMstack?So what makes},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/ZVGV3PFD/what-is-the-jamstack-and-how-do-i-host-my-website-on-it.html}
}

@incollection{freemanUnderstandingTypeScript2021,
  title = {Understanding {{TypeScript}}},
  booktitle = {Essential {{TypeScript}} 4: {{From Beginner}} to {{Pro}}},
  author = {Freeman, Adam},
  editor = {Freeman, Adam},
  year = {2021},
  pages = {35--41},
  publisher = {{Apress}},
  address = {{Berkeley, CA}},
  doi = {10.1007/978-1-4842-7011-0_2},
  url = {https://doi.org/10.1007/978-1-4842-7011-0_2},
  urldate = {2021-10-09},
  abstract = {TypeScript is a superset of the JavaScript language that focuses on producing safe and predictable code that can be executed by any JavaScript runtime. Its headline feature is static typing, which makes working with JavaScript more predictable for programmers familiar with languages such as C\# and Java. In this book, I explain what TypeScript does and describe the different features it provides.},
  isbn = {978-1-4842-7011-0},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/S6S3DMHH/Freeman - 2021 - Understanding TypeScript.pdf}
}

@incollection{gagliardiDjangoRESTMeets2021,
  title = {Django {{REST Meets Next}}.Js},
  booktitle = {Decoupled {{Django}}	: {{Understand}} and {{Build Decoupled Django Architectures}} for {{JavaScript Front-ends}}},
  author = {Gagliardi, Valentino},
  editor = {Gagliardi, Valentino},
  year = {2021},
  pages = {113--132},
  publisher = {{Apress}},
  address = {{Berkeley, CA}},
  doi = {10.1007/978-1-4842-7144-5_8},
  url = {https://doi.org/10.1007/978-1-4842-7144-5_8},
  abstract = {This chapter covers:},
  isbn = {978-1-4842-7144-5}
}

@misc{GraphQL,
  title = {{{GraphQL}}},
  url = {https://book.hacktricks.xyz/pentesting/pentesting-web/graphql},
  urldate = {2021-10-09},
  file = {/Users/dieman/Zotero/storage/5JGGCW3G/graphql.html}
}

@misc{graphqlbypopSuppressingProblemGraphQL2020,
  title = {Suppressing the {{N}}+1 {{Problem}} | {{GraphQL}} by {{PoP}}},
  author = {{GraphQL by PoP}},
  year = {2020},
  url = {https://graphql-by-pop.com/docs/architecture/suppressing-n-plus-one-problem.html#what-is-the-n-1-problem},
  urldate = {2021-10-11},
  abstract = {CMS-agnostic GraphQL server in PHP},
  langid = {american},
  file = {/Users/dieman/Zotero/storage/EQC6N8MA/suppressing-n-plus-one-problem.html}
}

@incollection{helmoldLeanManagementKPI2020,
  title = {Lean {{Management KPI}} and {{OKR}}},
  booktitle = {Lean {{Management}} and {{Kaizen}}: {{Fundamentals}} from {{Cases}} and {{Examples}} in {{Operations}} and {{Supply Chain Management}}},
  author = {Helmold, Marc},
  editor = {Helmold, Marc},
  year = {2020},
  series = {Management for {{Professionals}}},
  pages = {113--122},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-46981-8_12},
  url = {https://doi.org/10.1007/978-3-030-46981-8_12},
  urldate = {2021-10-09},
  abstract = {Lean management must be an integral part of any enterprise and organization. Performance improvements and permanent adjustments are important factors for the successful implementation of lean structures. Performance management therefore integrates a cycle from performance measurement and analysis (Plan), the performance action and implementation (Do), the performance management controlling (Check), and the performance improvements and adjustments (Act) as illustrated in the lean performance management cycle in Fig. 12.1. The figure shows the lean performance management cycle as an iterative and continuous process for the control and improvement of processes, products, or services. The original P-D-C-A four-step framework is also known as Deming circle (Slack 1995).},
  isbn = {978-3-030-46981-8},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/APISSDVG/Helmold - 2020 - Lean Management KPI and OKR.pdf}
}

@misc{khalilWhyYouShould2021,
  title = {Why {{You Should Disable GraphQL Introspection In Production}} \textendash{} {{GraphQL Security}}},
  author = {Khalil, Stemmler},
  year = {2021},
  journal = {Apollo GraphQL Blog},
  url = {https://www.apollographql.com/blog/graphql/security/why-you-should-disable-graphql-introspection-in-production/},
  urldate = {2021-10-09},
  abstract = {Once your graph is up and running in production, like anything else on the internet, it's a good idea to implement precautions to prevent it from being compromised by bad actors. Disabling introspection in production is a widely debated topic, but we believe it's one of the first things you can do to harden your [\ldots ]},
  file = {/Users/dieman/Zotero/storage/J9H2TXAN/why-you-should-disable-graphql-introspection-in-production.html}
}

@inproceedings{korenExploitationOpenAPIDocumentation2018,
  title = {The Exploitation of {{OpenAPI}} Documentation for the Generation of Web Frontends},
  booktitle = {Companion Proceedings of the the Web Conference 2018},
  author = {Koren, Istv{\'a}n and Klamma, Ralf},
  year = {2018},
  publisher = {{International World Wide Web Conferences Steering Committee}},
  doi = {10.1145/3184558.3188740},
  url = {https://doi.org/10.1145/3184558.3188740},
  abstract = {New Internet-enabled devices and Web services are introduced on a daily basis. Documentation formats are available that describe their functionalities in terms of API endpoints and parameters. In particular, the OpenAPI specification has gained considerable influence over the last years. Web-based solutions exist that generate interactive OpenAPI documentation with HTML5 \&amp; JavaScript. They allow developers to quickly get an understanding what the services and devices do and how they work. However, the generated user interfaces are far from real-world practices of designers and end users. We present an approach to overcome this gap, by using a model-driven methodology resulting in state-of-the-art responsive Web user interfaces. To this end, we use the Interaction Flow Modeling Language (IFML) as intermediary model specification to bring together APIs and frontends. Our implementation is based on open standards like Web Components and SVG. A screencast of our tool is available at https://youtu.be/KFOPmPShak4},
  isbn = {978-1-4503-5640-4}
}

@article{pratapyadavFormalApproachDocker2021,
  title = {A Formal Approach for {{Docker}} Container Deployment},
  author = {Pratap Yadav, Mahendra and Pal, Nisha and Kumar Yadav, Dharmendra},
  year = {2021},
  journal = {Concurrency and Computation: Practice and Experience},
  volume = {33},
  number = {20},
  pages = {e6364},
  issn = {1532-0634},
  doi = {10.1002/cpe.6364},
  url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/cpe.6364},
  urldate = {2021-10-09},
  abstract = {Container-based virtualization is becoming increasingly popular in the cloud industry, as it provides services to the client as per their requirements. Requirements of the user can be described in a configuration file. Cloud provider offers the services to the client using ``pay-as-you go'' model. Docker provides support to a cloud provider for the creation of a container, deployment of the container, and monitoring of services running inside a container on the host and guest system both. The creation and deployment of the container by Docker efficiently is a big challenge. In this paper, we capture the behavior of the container life cycle through process algebra (CCS) and properties of it as a formula using -calculus. Further we capture the behavior of deployment of the container on the host machine through CCS and its properties through the model - calculus. We used model checking tool Concurrency Workbench of the New Century to verify the creation of the Docker container as well as deployment of it.},
  langid = {english},
  keywords = {CCS,cloud computing,container,Docker,formal methods,virtualization},
  annotation = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/cpe.6364},
  file = {/Users/dieman/Zotero/storage/3MRD5MK5/Pratap Yadav et al. - 2021 - A formal approach for Docker container deployment.pdf;/Users/dieman/Zotero/storage/SLNE32PP/cpe.html}
}

@misc{rizwanGraphQLCommonVulnerabilities2021,
  title = {{{GraphQL}} \textemdash{} {{Common}} Vulnerabilities \& How to Exploit Them},
  author = {Rizwan, Bilal},
  year = {2021},
  month = feb,
  journal = {Medium},
  url = {https://the-bilal-rizwan.medium.com/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696},
  urldate = {2021-10-09},
  abstract = {Hello there! how you doin?~, Bilal Rizwan here \& I hope everyone is safe in this time of crisis and making complete use of your\ldots},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/6CGRL9PS/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696.html}
}

@book{soniEndEndAutomation2015,
  title = {End to {{End Automation}} on {{Cloud}} with {{Build Pipeline}}: {{The Case}} for {{DevOps}} in {{Insurance Industry}}, {{Continuous Integration}}, {{Continuous Testing}}, and {{Continuous Delivery}}},
  shorttitle = {2015 {{IEEE International Conference}} on {{Cloud Computing}} in {{Emerging Markets}} 25-27 {{November}} 2015, {{Bangalore}}, {{India}}},
  author = {Soni, Mitesh},
  year = {2015},
  url = {https://ieeexplore.ieee.org/document/7436936},
  urldate = {2021-10-06},
  isbn = {978-1-4673-8566-4},
  langid = {english},
  annotation = {OCLC: 956701216}
}

@misc{theagilehelpScrumVsKanban2020,
  title = {Scrum vs {{Kanban}}: Which One to Choose and Why? \textendash{} {{TheAgileHelp}}},
  shorttitle = {Scrum vs {{Kanban}}},
  author = {TheAgileHelp},
  year = {2020},
  url = {https://www.theagilehelp.com/scrum-vs-kanban-which-one-to-choose-and-why/},
  urldate = {2021-10-11},
  langid = {american},
  file = {/Users/dieman/Zotero/storage/LAMEXZHU/scrum-vs-kanban-which-one-to-choose-and-why.html}
}

@inproceedings{witternEmpiricalStudyGraphQL2019,
  title = {An {{Empirical Study}} of {{GraphQL Schemas}}},
  booktitle = {Service-{{Oriented Computing}}},
  author = {Wittern, Erik and Cha, Alan and Davis, James C. and Baudart, Guillaume and Mandel, Louis},
  editor = {Yangui, Sami and Bouassida Rodriguez, Ismael and Drira, Khalil and Tari, Zahir},
  year = {2019},
  pages = {3--19},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  url = {https://link.springer.com/chapter/10.1007/978-3-319-91662-0_5},
  abstract = {GraphQL is a query language for APIs and a runtime to execute queries. Using GraphQL queries, clients define precisely what data they wish to retrieve or mutate on a server, leading to fewer round trips and reduced response sizes. Although interest in GraphQL is on the rise, with increasing adoption at major organizations, little is known about what GraphQL interfaces look like in practice. This lack of knowledge makes it hard for providers to understand what practices promote idiomatic, easy-to-use APIs, and what pitfalls to avoid.},
  isbn = {978-3-030-33702-5}
}

@inproceedings{witternGeneratingGraphQLWrappersREST2018,
  title = {Generating {{GraphQL-Wrappers}} for {{REST}}(-like) {{APIs}}},
  booktitle = {Web {{Engineering}}},
  author = {Wittern, Erik and Cha, Alan and Laredo, Jim A.},
  editor = {Mikkonen, Tommi and Klamma, Ralf and Hern{\'a}ndez, Juan},
  year = {2018},
  pages = {65--83},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  abstract = {GraphQL is a query language and thereupon-based paradigm for implementing web Application Programming Interfaces (APIs) for client-server interactions. Using GraphQL, clients define precise, nested data-requirements in typed queries, which are resolved by servers against (possibly multiple) backend systems, like databases, object storages, or other APIs. Clients receive only the data they care about, in a single request. However, providers of existing REST(-like) APIs need to implement additional GraphQL interfaces to enable these advantages. We here assess the feasibility of automatically generating GraphQL wrappers for existing REST(-like) APIs. A wrapper, upon receiving GraphQL queries, translates them to requests against the target API. We discuss the challenges for creating such wrappers, including dealing with data sanitation, authentication, or handling nested queries. We furthermore present a prototypical implementation of OASGraph. OASGraph takes as input an OpenAPI Specification (OAS) describing an existing REST(-like) web API and generates a GraphQL wrapper for it. We evaluate OASGraph by running it, as well as an existing open source alternative, against 959 publicly available OAS. This experiment shows that OASGraph outperforms the existing alternative and is able to create a GraphQL wrapper for \$\$89.5\textbackslash\%\$\$of the APIs \textendash{} however, with limitations in many cases. A subsequent analysis of errors and warnings produced by OASGraph shows that missing or ambiguous information in the assessed OAS hinders creating complete wrappers. Finally, we present a use case of the IBM Watson Language Translator API that shows that small changes to an OAS allow OASGraph to generate more idiomatic and more expressive GraphQL wrappers.},
  isbn = {978-3-319-91662-0}
}

@misc{yeswehackHowExploitGraphQL2021,
  title = {How to Exploit {{GraphQL}} Endpoint: Introspection, Query, Mutations \& Tools},
  shorttitle = {How to Exploit {{GraphQL}} Endpoint},
  author = {YesWeHack},
  year = {2021},
  month = mar,
  journal = {Global Bug Bounty Platform},
  url = {https://blog.yeswehack.com/yeswerhackers/how-exploit-graphql-endpoint-bug-bounty/},
  urldate = {2021-10-09},
  abstract = {How to exploit a GraphQL endpoint. How to perform Introspection and Mutations? Learn more about tools, bathing attacks, fuzzing and IDORs!},
  langid = {american},
  file = {/Users/dieman/Zotero/storage/2YKFW8AM/how-exploit-graphql-endpoint-bug-bounty.html}
}

@article{yuUtilisingCIEnvironment2020,
  title = {Utilising {{CI}} Environment for Efficient and Effective Testing of {{NFRs}}},
  author = {Yu, Liang and Al{\'e}groth, Emil and Chatzipetrou, Panagiota and Gorschek, Tony},
  year = {2020},
  month = jan,
  journal = {Information and Software Technology},
  volume = {117},
  pages = {106199},
  issn = {0950-5849},
  doi = {10.1016/j.infsof.2019.106199},
  url = {https://www.sciencedirect.com/science/article/pii/S095058491930206X},
  urldate = {2021-10-09},
  abstract = {Context Continuous integration (CI) is a practice that aims to continuously verify quality aspects of a software intensive system both for functional and non-functional requirements (NFRs). Functional requirements are the inputs of development and can be tested in isolation, utilising either manual or automated tests. In contrast, some NFRs are difficult to test without functionality, for NFRs are often aspects of functionality and express quality aspects. Lacking this testability attribute makes NFR testing complicated and, therefore, underrepresented in industrial practice. However, the emergence of CI has radically affected software development and created new avenues for software quality evaluation and quality information acquisition. Research has, consequently, been devoted to the utilisation of this additional information for more efficient and effective NFR verification. Objective We aim to identify the state-of-the-art of utilising the CI environment for NFR testing, hereinafter referred to as CI-NFR testing. Method Through rigorous selection, from an initial set of 747 papers, we identified 47 papers that describe how NFRs are tested in a CI environment. Evidence-based analysis, through coding, is performed on the identified papers in this SLR. Results Firstly, ten CI approaches are described by the papers selected, each describing different tools and nine different NFRs where reported to be tested. Secondly, although possible, CI-NFR testing is associated with eight challenges that adversely affect its adoption. Thirdly, the identified CI-NFR testing processes are tool-driven, but there is a lack of NFR testing tools that can be used in the CI environment. Finally, we proposed a CI framework for NFRs testing. Conclusion A synthesised CI framework is proposed for testing various NFRs, and associated CI tools are also mapped. This contribution is valuable as results of the study also show that CI-NFR testing can help improve the quality of NFR testing in practices.},
  langid = {english},
  keywords = {Agile,CI,Continuous integration,DevOps,NFR,Non-functional requirement,SAFe,Scaled agile framework},
  file = {/Users/dieman/Zotero/storage/D5MCR22Y/S095058491930206X.html}
}

@incollection{zammettiWhatJAMstackAll2020,
  title = {What {{Is JAMstack All About}}?},
  booktitle = {Practical {{JAMstack}}: {{Blazing Fast}}, {{Simple}}, and {{Secure Web Development}}, the {{Modern Way}}},
  author = {Zammetti, Frank},
  editor = {Zammetti, Frank},
  year = {2020},
  pages = {1--17},
  publisher = {{Apress}},
  address = {{Berkeley, CA}},
  doi = {10.1007/978-1-4842-6177-4_1},
  url = {https://doi.org/10.1007/978-1-4842-6177-4_1},
  urldate = {2021-10-09},
  abstract = {Welcome, dear reader, to the book!},
  isbn = {978-1-4842-6177-4},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/223YYP6A/Zammetti - 2020 - What Is JAMstack All About.pdf}
}

@article{zayatFrameworkStudyAgile2020,
  title = {Framework {{Study}} for {{Agile Software Development Via Scrum}} and {{Kanban}}},
  author = {Zayat, Wael and Senvar, Ozlem},
  year = {2020},
  month = jun,
  journal = {International Journal of Innovation and Technology Management},
  volume = {17},
  number = {04},
  pages = {2030002},
  publisher = {{World Scientific Publishing Co.}},
  issn = {0219-8770},
  doi = {10.1142/S0219877020300025},
  url = {https://www.worldscientific.com/doi/epdf/10.1142/S0219877020300025},
  urldate = {2021-10-06},
  abstract = {This paper provides a systematic comparison between two well-known Agile methodologies: Scrum, which is a framework of doing projects by allocating tasks into small stages called sprints, and Kanban, which is a scheduling system to manage the flow of work by means of visual signals. In this regard, both methodologies were reviewed to explore similarities and differences between them. Then, a focus group survey was performed to specify the preferable methodology for product development according to various parameters in the project environment including project complexity, level of uncertainty, and work size with consideration of output factors like quality, productivity, and delivery. Results show the flexibility of both methodologies in approaching Agile objectives, where Scrum emphasizes on the corporation of the customer and development teams with a focus on particular skills such as planning, organization, presentation, and reviewing which makes it ideal for new and complex projects where a regular involvement of the customer is required, whereas Kanban is more operative in continuous-flow environments with a steady approach toward a system improvement.}
}


