
@inproceedings{britoRESTVsGraphQL2020,
  title = {{{REST}} vs {{GraphQL}}: A {{Controlled Experiment}}},
  shorttitle = {{{REST}} vs {{GraphQL}}},
  booktitle = {2020 {{IEEE International Conference}} on {{Software Architecture}} ({{ICSA}})},
  author = {Brito, Gleison and Valente, Marco Tulio},
  year = {2020},
  month = mar,
  pages = {81--91},
  doi = {10.1109/ICSA47634.2020.00016},
  abstract = {GraphQL is a novel query language for implementing service-based software architectures. The language is gaining momentum and it is now used by major software companies, such as Facebook and GitHub. However, we still lack empirical evidence on the real gains achieved by GraphQL, particularly in terms of the effort required to implement queries in this language. Therefore, in this paper we describe a controlled experiment with 22 students (10 undergraduate and 12 graduate), who were asked to implement eight queries for accessing a web service, using GraphQL and REST. Our results show that GraphQL requires less effort to implement remote service queries when compared to REST (9 vs 6 minutes, median times). These gains increase when REST queries include more complex endpoints, with several parameters. Interestingly, GraphQL outperforms REST even among more experienced participants (as is the case of graduate students) and among participants with previous experience in REST, but no previous experience in GraphQL.},
  keywords = {Database languages,Facebook,GraphQL,REST,Servers,Standards,Task analysis,Uniform resource locators,Web APIs,Web services},
  file = {/Users/dieman/Zotero/storage/9Q6FIMH5/Brito and Valente - 2020 - REST vs GraphQL A Controlled Experiment.pdf;/Users/dieman/Zotero/storage/NPGE8KS4/9101226.html}
}

@article{fanWhyAPIDocumentation2021,
  title = {Why {{API}} Documentation Is Insufficient for Developers: An Empirical Study},
  shorttitle = {Why {{API}} Documentation Is Insufficient for Developers},
  author = {Fan, Qiang and Yu, Yue and Wang, Tao and Yin, Gang and Wang, Huaimin},
  year = {2021},
  month = jan,
  journal = {Science China Information Sciences},
  volume = {64},
  number = {1},
  pages = {119102},
  issn = {1674-733X, 1869-1919},
  doi = {10.1007/s11432-019-9880-8},
  url = {http://link.springer.com/10.1007/s11432-019-9880-8},
  urldate = {2021-10-09},
  langid = {english},
  file = {/Users/dieman/Zotero/storage/AHAAF7QW/Fan et al. - 2021 - Why API documentation is insufficient for develope.pdf}
}

@misc{GraphQL,
  title = {{{GraphQL}}},
  url = {https://book.hacktricks.xyz/pentesting/pentesting-web/graphql},
  urldate = {2021-10-09},
  file = {/Users/dieman/Zotero/storage/5JGGCW3G/graphql.html}
}

@misc{khalilWhyYouShould2021,
  title = {Why {{You Should Disable GraphQL Introspection In Production}} \textendash{} {{GraphQL Security}}},
  author = {Khalil, Stemmler},
  year = {2021},
  journal = {Apollo GraphQL Blog},
  url = {https://www.apollographql.com/blog/graphql/security/why-you-should-disable-graphql-introspection-in-production/},
  urldate = {2021-10-09},
  abstract = {Once your graph is up and running in production, like anything else on the internet, it's a good idea to implement precautions to prevent it from being compromised by bad actors. Disabling introspection in production is a widely debated topic, but we believe it's one of the first things you can do to harden your [\ldots ]},
  file = {/Users/dieman/Zotero/storage/J9H2TXAN/why-you-should-disable-graphql-introspection-in-production.html}
}

@inproceedings{korenExploitationOpenAPIDocumentation2018,
  title = {The Exploitation of {{OpenAPI}} Documentation for the Generation of Web Frontends},
  booktitle = {Companion Proceedings of the the Web Conference 2018},
  author = {Koren, Istv{\'a}n and Klamma, Ralf},
  year = {2018},
  publisher = {{International World Wide Web Conferences Steering Committee}},
  doi = {10.1145/3184558.3188740},
  url = {https://doi.org/10.1145/3184558.3188740},
  abstract = {New Internet-enabled devices and Web services are introduced on a daily basis. Documentation formats are available that describe their functionalities in terms of API endpoints and parameters. In particular, the OpenAPI specification has gained considerable influence over the last years. Web-based solutions exist that generate interactive OpenAPI documentation with HTML5 \&amp; JavaScript. They allow developers to quickly get an understanding what the services and devices do and how they work. However, the generated user interfaces are far from real-world practices of designers and end users. We present an approach to overcome this gap, by using a model-driven methodology resulting in state-of-the-art responsive Web user interfaces. To this end, we use the Interaction Flow Modeling Language (IFML) as intermediary model specification to bring together APIs and frontends. Our implementation is based on open standards like Web Components and SVG. A screencast of our tool is available at https://youtu.be/KFOPmPShak4},
  isbn = {978-1-4503-5640-4}
}

@book{soniEndEndAutomation2015,
  title = {End to {{End Automation}} on {{Cloud}} with {{Build Pipeline}}: The {{Case}} for {{DevOps}} in {{Insurance Industry}}, {{Continuous Integration}}, {{Continuous Testing}}, and {{Continuous Delivery}}},
  shorttitle = {2015 {{IEEE International Conference}} on {{Cloud Computing}} in {{Emerging Markets}} 25-27 {{November}} 2015, {{Bangalore}}, {{India}}},
  author = {Soni, Mitesh},
  year = {2015},
  url = {https://ieeexplore.ieee.org/document/7436936},
  urldate = {2021-10-06},
  isbn = {978-1-4673-8566-4},
  langid = {english},
  annotation = {OCLC: 956701216}
}

@inproceedings{witternEmpiricalStudyGraphQL2019a,
  title = {An {{Empirical Study}} of {{GraphQL Schemas}}},
  booktitle = {Service-{{Oriented Computing}}},
  author = {Wittern, Erik and Cha, Alan and Davis, James C. and Baudart, Guillaume and Mandel, Louis},
  editor = {Yangui, Sami and Bouassida Rodriguez, Ismael and Drira, Khalil and Tari, Zahir},
  year = {2019},
  pages = {3--19},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  url = {https://link.springer.com/chapter/10.1007/978-3-319-91662-0_5},
  abstract = {GraphQL is a query language for APIs and a runtime to execute queries. Using GraphQL queries, clients define precisely what data they wish to retrieve or mutate on a server, leading to fewer round trips and reduced response sizes. Although interest in GraphQL is on the rise, with increasing adoption at major organizations, little is known about what GraphQL interfaces look like in practice. This lack of knowledge makes it hard for providers to understand what practices promote idiomatic, easy-to-use APIs, and what pitfalls to avoid.},
  isbn = {978-3-030-33702-5}
}

@inproceedings{witternGeneratingGraphQLWrappersREST2018,
  title = {Generating {{GraphQL}}-{{Wrappers}} for {{REST}}(-like) {{APIs}}},
  booktitle = {Web {{Engineering}}},
  author = {Wittern, Erik and Cha, Alan and Laredo, Jim A.},
  editor = {Mikkonen, Tommi and Klamma, Ralf and Hern{\'a}ndez, Juan},
  year = {2018},
  pages = {65--83},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  abstract = {GraphQL is a query language and thereupon-based paradigm for implementing web Application Programming Interfaces (APIs) for client-server interactions. Using GraphQL, clients define precise, nested data-requirements in typed queries, which are resolved by servers against (possibly multiple) backend systems, like databases, object storages, or other APIs. Clients receive only the data they care about, in a single request. However, providers of existing REST(-like) APIs need to implement additional GraphQL interfaces to enable these advantages. We here assess the feasibility of automatically generating GraphQL wrappers for existing REST(-like) APIs. A wrapper, upon receiving GraphQL queries, translates them to requests against the target API. We discuss the challenges for creating such wrappers, including dealing with data sanitation, authentication, or handling nested queries. We furthermore present a prototypical implementation of OASGraph. OASGraph takes as input an OpenAPI Specification (OAS) describing an existing REST(-like) web API and generates a GraphQL wrapper for it. We evaluate OASGraph by running it, as well as an existing open source alternative, against 959 publicly available OAS. This experiment shows that OASGraph outperforms the existing alternative and is able to create a GraphQL wrapper for \$\$89.5\textbackslash\%\$\$of the APIs \textendash{} however, with limitations in many cases. A subsequent analysis of errors and warnings produced by OASGraph shows that missing or ambiguous information in the assessed OAS hinders creating complete wrappers. Finally, we present a use case of the IBM Watson Language Translator API that shows that small changes to an OAS allow OASGraph to generate more idiomatic and more expressive GraphQL wrappers.},
  isbn = {978-3-319-91662-0}
}

@article{zayatFrameworkStudyAgile2020,
  title = {Framework {{Study}} for {{Agile Software Development Via Scrum}} and {{Kanban}}},
  author = {Zayat, Wael and Senvar, Ozlem},
  year = {2020},
  month = jun,
  journal = {International Journal of Innovation and Technology Management},
  volume = {17},
  number = {04},
  pages = {2030002},
  publisher = {{World Scientific Publishing Co.}},
  issn = {0219-8770},
  doi = {10.1142/S0219877020300025},
  url = {https://www.worldscientific.com/doi/epdf/10.1142/S0219877020300025},
  urldate = {2021-10-06},
  abstract = {This paper provides a systematic comparison between two well-known Agile methodologies: Scrum, which is a framework of doing projects by allocating tasks into small stages called sprints, and Kanban, which is a scheduling system to manage the flow of work by means of visual signals. In this regard, both methodologies were reviewed to explore similarities and differences between them. Then, a focus group survey was performed to specify the preferable methodology for product development according to various parameters in the project environment including project complexity, level of uncertainty, and work size with consideration of output factors like quality, productivity, and delivery. Results show the flexibility of both methodologies in approaching Agile objectives, where Scrum emphasizes on the corporation of the customer and development teams with a focus on particular skills such as planning, organization, presentation, and reviewing which makes it ideal for new and complex projects where a regular involvement of the customer is required, whereas Kanban is more operative in continuous-flow environments with a steady approach toward a system improvement.}
}


